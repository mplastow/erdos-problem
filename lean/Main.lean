-- Generated by ChatGPT's Math Solver on April 23, 2025

-- Note: Does not compile!

import Mathlib.Data.Nat.Prime.Basic
import Mathlib.Data.Nat.GCD.Basic

open Nat

instance : ∀ n, Decidable (Nat.Prime n) := Nat.decidablePrime

def isVisible (p : ℕ × ℕ) : Prop :=
  gcd p.1 p.2 = 1

def isPrimePair (p : ℕ × ℕ) : Prop :=
  Nat.Prime p.1 ∧ Nat.Prime p.2

def safeNextPoint (p : ℕ × ℕ) : ℕ × ℕ :=
  let right := (p.1 + 1, p.2)
  let up := (p.1, p.2 + 1)
  if h₁ : isVisible right ∧ ¬ isPrimePair right then
    right
  else if h₂ : isVisible up ∧ ¬ isPrimePair up then
    up
  else
    right

def Path : ℕ → ℕ × ℕ
| 0 => (1, 1)
| (n + 1) => safeNextPoint (Path n)

-- Coordinate accessors
def PathX (n : ℕ) := (Path n).1
def PathY (n : ℕ) := (Path n).2

-- Both coordinates go to infinity
theorem path_goes_to_infinity :
  ∀ m : ℕ, ∃ n : ℕ, PathX n ≥ m ∧ PathY n ≥ m := by
  intro m
  -- We proceed by simple bounding:
  -- Since we take either right or up steps,
  -- we take at least one x-step or one y-step every time
  -- So after 2m steps, we must have increased both coordinates to ≥ m
  use (2 * m)
  -- We'll prove this by induction or bounding directly
  have h_step : ∀ n, PathX (n + 1) ≥ PathX n ∧ PathY (n + 1) ≥ PathY n := by
    intro n
    unfold PathX PathY Path safeNextPoint
    split_ifs with h₁ h₂ <;> simp [Nat.succ_le_succ, Nat.le_succ]

  -- Now prove that PathX and PathY are monotonic
  have mono_x : ∀ n, PathX n ≤ PathX (2 * m) := by
    intro n
    induction' n with n ih
    · simp
    · specialize h_step n
      exact le_trans ih h_step.1

  have mono_y : ∀ n, PathY n ≤ PathY (2 * m) := by
    intro n
    induction' n with n ih
    · simp
    · specialize h_step n
      exact le_trans ih h_step.2

  -- Conclude by bounding:
  apply And.intro
  · have : m ≤ 2 * m := Nat.le_mul_of_pos_right m (by norm_num)
    exact le_trans this (mono_x m)
  · have : m ≤ 2 * m := Nat.le_mul_of_pos_right m (by norm_num)
    exact le_trans this (mono_y m)
