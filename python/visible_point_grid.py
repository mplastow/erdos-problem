# Generated by ChatGPT on May 15, 2025
# Last edited by Matt Plastow on May 19, 2025

import numpy as np
import matplotlib.pyplot as plt

from prime_cache import (
    load_or_generate_primes,
    load_or_generate_semiprimes
)


# Global variables
prime_set: set[int]
semiprime_set: set[int]

"""
Specifies a grid.
"""
class GridSpec:
    def __init__(self, min_x: int, min_y: int, max_x: int, max_y: int, dim_x: int, dim_y: int):
        self.min_x = min_x
        self.max_x = max_x
        self.min_y = min_y
        self.max_y = max_y

        self.dim_x = dim_x
        self.dim_y = dim_y

"""
Determines whether a number is prime. Searches a set of generated prime numbers
to avoid recomputing primes dynamically.
"""
def is_prime(num: int, primes: set[int]) -> bool:
    return num in primes

"""
Determines whether a number is semiprime. Searches a set of generated semiprime numbers
to avoid recomputing semiprimes dynamically.
"""
def is_distinct_semiprime(num: int, semiprimes: set[int]) -> bool:
    return num in semiprimes

"""
Calculates visibility from the origin. The criterion for visibility is that the
greatest common divisor of the x- and y-coordinates is 1.
"""
def is_visible(coord_x: int, coord_y: int) -> bool:
    if np.gcd(coord_x, coord_y) == 1:
        # print(f"({x},{y}) is visible")
        return True
    else:
        return False

"""
Generates an array representing a grid of points from (min_x, min_y) to (max_x, max_y), inclusive. 
The element corresponding to each point has the value 1 if it is visible from the origin and 0 if it is not.
"""
def generate_vis_grid(grid: GridSpec) -> list[int]:
    result = []
    for coord_y in range(grid.min_y, grid.max_y):
        for coord_x in range(grid.min_x, grid.max_x):
            vis = 1 if is_visible(coord_x, coord_y) else 0
            result.append(vis)
    return result

"""
Marks grid points with coprime coordinates as inaccessible.
"""
def mark_coprimes(grid: GridSpec, data: list[int]) -> None:
    for index_y in range(grid.dim_y):
        coord_y = grid.min_y + index_y
        if is_prime(coord_y, prime_set):
            for index_x in range(grid.dim_x):
                coord_x = grid.min_x + index_x
                if is_prime(coord_x, prime_set):
                    index = index_x + index_y * grid.dim_x
                    data[index] = 0

"""
Takes an array generated by `generate_vis_grid`.
Works backward from the upper-left corner of the grid to mark all dead ends.
A "dead end" is a point that does not lie on a path that leads out of the grid.
"""
def mark_deadends(grid: GridSpec, data: list[int]) -> None:
    for coord_y in range(grid.dim_y - 2, -1, -1):
        for coord_x in range(grid.dim_x - 2, -1, -1):
            index = coord_x + (coord_y * grid.dim_x)
            index_one_right = index + 1
            index_one_above = index + grid.dim_x

            # Criteria for a dead-end point:
            # the point to the right is blocked AND the point above is blocked
            if data[index_one_right] == 0 and data[index_one_above] == 0:
                data[index] = 0

"""
Plots a grid of points generated by `generate_vis_grid`.
"""
def plot_point_grid(grid: GridSpec, data: list[int]) -> None:
    # Convert to 2D NumPy array
    grid_array = np.array(data, dtype=np.uint8).reshape((grid.dim_y, grid.dim_x))

    # Get coordinates of visible points (value == 1)
    y_indices, x_indices = np.nonzero(grid_array)

    # Convert indices to actual x, y coordinates
    x_coords = x_indices + grid.min_x
    y_coords = y_indices + grid.min_y

    # Plot visible points
    plt.figure(figsize = (10, 10))
    plt.scatter(x_coords, y_coords, color = 'black', s = 6)
    plt.title('Visible points with no coprimes and no dead ends')
    plt.xlabel('x')
    plt.ylabel('y')
    plt.xlim(grid.min_x, grid.max_x + 1)
    plt.ylim(grid.min_y, grid.max_y + 1)
    plt.grid(False)
    plt.axis('equal')
    plt.show()

# # # # # # # # # # # 
# Program entry point
# # # # # # # # # # # 

# The min and max values in the point grid.
# Intervals in Python are right-open (e.g. max_x must be 51 to include x = 50)
# EDIT:
min_x: int = 110000
max_x: int = 110200
min_y: int = 110000
max_y: int = 110200

# The max value to generate primes and semiprimes up to.
# The default value of `1000000` will generate all primes and distinct semiprimes 
# up to 1 million and cache them on disk for use in all subsequent checks.
# EDIT:
primes_semiprimes_max: int = 1000000

# Generate primes and semiprimes up to the max (above) and cache them on disk for faster lookup.
# NOTE: These functions will write .pkl files to your environment. If you generate lots of these files,
# you may want to delete them every once in a while to keep disk usage down.
prime_set = load_or_generate_primes(primes_semiprimes_max)
semiprime_set = load_or_generate_semiprimes(primes_semiprimes_max, prime_set)

dim_x: int = max_x - min_x
dim_y: int = max_y - min_y

grid_spec = GridSpec(min_x = min_x, max_x = max_x, min_y = min_y, max_y = max_y, dim_x = dim_x, dim_y = dim_y)

data: list[int] = generate_vis_grid(grid_spec)

# Commenting out the line below will include coprime points in the plot
mark_coprimes(grid_spec, data)

# Commenting out the line below will include dead-end points in the plot
mark_deadends(grid_spec, data)

# Finally, plot the grid of points
plot_point_grid(grid_spec, data)