# Generated by ChatGPT on May 15, 2025
# Last edited by Matt Plastow on May 21, 2025

import numpy as np
import matplotlib.pyplot as plt

from prime_cache import (
    init_cache_primes,
    init_cache_distinct_semiprimes,
    is_prime,
    is_distinct_semiprime
)

# Global variables
prime_set: set[int]
semiprime_set: set[int]

class GridSpec:
    """
    Specifies a grid for use in this program.
    """
    def __init__(self, min_x: int, min_y: int, max_x: int, max_y: int, dim_x: int, dim_y: int):
        self.min_x = min_x
        self.max_x = max_x
        self.min_y = min_y
        self.max_y = max_y

        self.dim_x = dim_x
        self.dim_y = dim_y

def is_visible(coord_x: int, coord_y: int) -> bool:
    """
    Calculates visibility from the origin. The criterion for visibility is that the
    greatest common divisor of the x- and y-coordinates is 1.
    """
    if np.gcd(coord_x, coord_y) == 1:
        # print(f"({x},{y}) is visible")
        return True
    else:
        return False

def generate_vis_grid(grid: GridSpec) -> list[int]:
    """
    Generates an array representing a grid of points from (min_x, min_y) to (max_x, max_y), inclusive. 
    The element corresponding to each point has the value 1 if it is visible from the origin and 0 if it is not.
    """
    result = []
    for coord_y in range(grid.min_y, grid.max_y):
        for coord_x in range(grid.min_x, grid.max_x):
            vis = 1 if is_visible(coord_x, coord_y) else 0
            result.append(vis)
    return result

def mark_coprimes(grid: GridSpec, data: list[int]) -> None:
    """
    Marks grid points with coprime coordinates as inaccessible.
    """
    for index_y in range(grid.dim_y):
        coord_y = grid.min_y + index_y
        if is_prime(coord_y, prime_set):
            for index_x in range(grid.dim_x):
                coord_x = grid.min_x + index_x
                if is_prime(coord_x, prime_set):
                    index = index_x + index_y * grid.dim_x
                    data[index] = 0

def mark_deadends(grid: GridSpec, data: list[int]) -> None:    
    """
    Takes an array generated by `generate_vis_grid`.
    Works backward from the upper-left corner of the grid to mark all dead ends.
    A "dead end" is a point that does not lie on a path that leads out of the grid.
    """
    for coord_y in range(grid.dim_y - 2, -1, -1):
        for coord_x in range(grid.dim_x - 2, -1, -1):
            index = coord_x + (coord_y * grid.dim_x)
            index_one_right = index + 1
            index_one_above = index + grid.dim_x

            # Criteria for a dead-end point:
            # the point to the right is blocked AND the point above is blocked
            if data[index_one_right] == 0 and data[index_one_above] == 0:
                data[index] = 0

def plot_point_grid(grid: GridSpec, data: list[int]) -> None:
    """
    Plots a grid of points generated by `generate_vis_grid`.
    """
    # Convert to 2D NumPy array
    grid_array = np.array(data, dtype=np.uint8).reshape((grid.dim_y, grid.dim_x))

    # Get coordinates of visible points (value == 1)
    y_indices, x_indices = np.nonzero(grid_array)

    # Convert indices to actual x, y coordinates
    x_coords = x_indices + grid.min_x
    y_coords = y_indices + grid.min_y

    # Plot visible points
    plt.figure(figsize = (10, 10))
    colors = np.where(y_coords in semiprime_set)
    plt.scatter(x_coords, y_coords, color = colors, s = 11)
    plt.title('Visible points with no coprimes and no dead ends')
    plt.xlabel('x')
    plt.ylabel('y')
    plt.xlim(grid.min_x, grid.max_x + 1)
    plt.ylim(grid.min_y, grid.max_y + 1)
    plt.grid(False)
    plt.axis('equal')
    plt.show()

def plot_point_grid_color_semiprimes(grid: GridSpec, data: list[int], semiprime_set: set[int]) -> None:
    """
    Plots a grid of points, coloring those with x or y semiprime.
    Shows coordinates on hover.
    """
    grid_array = np.array(data, dtype=np.uint8).reshape((grid.dim_y, grid.dim_x))
    y_indices, x_indices = np.nonzero(grid_array)
    x_coords = x_indices + grid.min_x
    y_coords = y_indices + grid.min_y

    colors = np.array([
        'red' if (x in semiprime_set or y in semiprime_set) else 'gray'
        for x, y in zip(x_coords, y_coords)
    ])

    fig, ax = plt.subplots(figsize=(10, 10))
    scatter = ax.scatter(x_coords, y_coords, color=colors, s=20)
    ax.set_title('Visible points with no coprimes and no dead ends. Semiprimes are highlighted in red.')
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.set_xlim(grid.min_x, grid.max_x + 1)
    ax.set_ylim(grid.min_y, grid.max_y + 1)
    ax.grid(False)
    ax.axis('equal')

    annot = ax.annotate("", xy=(0,0), xytext=(10,10), textcoords="offset points",
                        bbox=dict(boxstyle="round", fc="w"),
                        arrowprops=dict(arrowstyle="->"))
    annot.set_visible(False)

    # This function updates the annotation position and text
    def update_annot(ind):
        # ind is a dict with key 'ind' -> list of point indices under cursor
        idx = ind["ind"][0]
        pos = scatter.get_offsets()[idx]
        annot.xy = pos
        text = f"({int(pos[0])}, {int(pos[1])})"
        annot.set_text(text)
        annot.get_bbox_patch().set_alpha(0.8)


    def hover(event):
        vis = annot.get_visible()
        if event.inaxes == ax:
            cont, ind = scatter.contains(event)
            if cont:
                update_annot(ind)
                annot.set_visible(True)
                fig.canvas.draw_idle()
            else:
                if vis:
                    annot.set_visible(False)
                    fig.canvas.draw_idle()

    fig.canvas.mpl_connect("motion_notify_event", hover)
    plt.show()

# # # # # # # # # # # 
# Program entry point
# # # # # # # # # # # 

# The min and max values in the point grid.
# Intervals in Python are right-open (e.g. max_x must be 51 to include x = 50)
# EDIT HERE:
min_x: int = 10000
max_x: int = 10101
min_y: int = 10000
max_y: int = 10101

# The max value to generate primes and semiprimes up to.
# The default value of `1000000` will generate all primes and distinct semiprimes 
# up to 1 million and cache them on disk for use in all subsequent checks.
# EDIT HERE:
primes_semiprimes_max: int = 1000000

# Generate primes and semiprimes up to the max (above) and cache them on disk for faster lookup.
# NOTE: These functions will write .pkl files to your environment. If you generate lots of these files,
# you may want to delete them every once in a while to keep disk usage down.
prime_set = init_cache_primes(primes_semiprimes_max)
semiprime_set = init_cache_distinct_semiprimes(primes_semiprimes_max, prime_set)

dim_x: int = max_x - min_x
dim_y: int = max_y - min_y

grid_spec = GridSpec(min_x = min_x, max_x = max_x, min_y = min_y, max_y = max_y, dim_x = dim_x, dim_y = dim_y)

data: list[int] = generate_vis_grid(grid_spec)

# Commenting out the line below will include coprime points in the plot
mark_coprimes(grid_spec, data)

# Commenting out the line below will include dead-end points in the plot
mark_deadends(grid_spec, data)

# Finally, plot the grid of points
plot_point_grid_color_semiprimes(grid_spec, data, semiprime_set)